/* 
< 함수 표현식 >

자바스크림트는 함수를 특별한 종류의 값으로 취급한다. 다른 언어에서처럼 특별한 동작을 하는 구조로 취급되지 않는다.

이 전에는 함수 선언문 방식으로 함수를 만들었다.
function sayHi() {
  alert( "Hello" );
}

함수 표현식으로 함수를 만들 수 있다.
let sayHi = function() {
  alert( "Hello" );
};
함수를 생성하고 변수에 값을 할당하는 것처럼 함수가 변수에 할당되었다. 함수가 어떤 방식으로 만들어졌는지에 관계없이
함수는 값이고, 따라서 변수에 할당할 수 있다. 위 예시에선 함수가 변수 sayHi에 저장된 값이 되었다.
> 말로 표현하면 "함수를 만들고 그 함수를 변수 sayHi에 할당하기" 
함수는 값이기때문에 alert를 이용하여 함수 코드를 출력할 수도 있다. 

function sayHi() {
  alert( "Hello" );
}

alert( sayHi ); // 함수 코드가 보임

sayHi옆에 괄호가 없기 때문에 함수는 실행되지 않는다. 어떤 언어에선 괄호없이 함수 이름만 언급해도 함수가 실행된다. 
하지만 자바스크립트는 괄호가 있어야만 함수가 호출된다. 
자바스크립트에서 함수는 값이다. 따라서 함수를 값처럼 취급할 수 있다. 위 코드에선 함수 소스 코드가 문자형으로 바뀌어 출력되었다. 

변수를 복사해 다른 변수에 할당하는 것처럼 함수를 복사해 다른 변수에 할당할 수도 있다.
function sayHi() {   // (1) 함수 생성
  alert( "Hello" );
}

let func = sayHi;    // (2) 함수 복사

func(); // Hello     // (3) 복사한 함수를 실행(정상적으로 실행됩니다)!
sayHi(); // Hello    //     본래 함수도 정상적으로 실행됩니다.

< 콜백함수 > 
함수를 값처럼 전달하는 예시, 함수 표현식에 관한 예시를 좀 더 살펴보겠습니다.
매개변수가 3개 있는 함수 ask (question, yes, no)를 작성해본다고 하면 
question 은 질문 / yes 는 yes라고 답한 경우 실행되는 함수 / no 는 no라고 답한 경우 실행되는 함수 

함수는 반드시 question을 해야하고 사용자의 답변에 따라 yes()나 no()를 호출한다.

function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "동의하셨습니다." );
}

function showCancel() {
  alert( "취소 버튼을 누르셨습니다." );
}

// 사용법: 함수 showOk와 showCancel가 ask 함수의 인수로 전달됨
ask("동의하십니까?", showOk, showCancel);

함수 ask의 인수, showOk와 showCancel은 콜백 함수 또는 콜백이라고 불린다.
함수를 함수의 인수로 전달하고 필요하다면 인수로 전달한 그 함수를 "나중에 호출" 하는것이 콜백 함수의 개념이다.
위 예시에선 사용자가 "yes"라고 대답한 경우 showOk가 콜백이 되고, "no"라고 대답한 경우 showCancel가 콜백된다. 

아래 처럼 함수 표현식을 사용하면 코드 길이가 짧아진다. 
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
);

< 함수표현식 vs 함수선언문 >
함수 표현식과 선언문의 차이는 무엇일까 ?

***** 함수 선언문 : 함수는 주요 코드 흐름 중간에 독자적인 구문 형태로 존재한다. 
// 함수 선언문
function sum(a, b) {
  return a + b;
}

***** 함수 표현식 : 함수는 표현식이나 구문 구성 내부에 생성된다. 아래 예시에선 함수가 할당연산자= 를 이용해 만든 "할당표현식" 우측에 생성되었다.
// 함수 표현식
let sum = function(a, b) {
  return a + b;
};

1. 함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다. 
    따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있다. 

2. 함수 선언문은 함수 선언문이 정의되기 전에도 호출할 수 있다. 

3. 엄격 모드에서 함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다. 
    하지만 블록 밖에서는 함수에 접근하지 못한다. 



let age = prompt("나이를 알려주세요.", 18);

// 조건에 따라 함수를 선언함
if (age < 18) {

  function welcome() {
    alert("안녕!");
  }

} else {

  function welcome() {
    alert("안녕하세요!");
  }

}
// 함수를 나중에 호출합니다.
welcome(); // Error: welcome is not defined
함수 선언문은 함수가 선언된 코드 블록 안에서만 유효하기 때문에 이런 에러가 발생한다.

let age = 16; // 16을 저장했다 가정합시다.

if (age < 18) {
  welcome();               // \   (실행)
                           //  |
  function welcome() {     //  |
    alert("안녕!");        //  |  함수 선언문은 함수가 선언된 블록 내
  }                        //  |  어디에서든 유효합니다
                           //  |
  welcome();               // /   (실행)

} else {

  function welcome() {
    alert("안녕하세요!");
  }
}
// 여기는 중괄호 밖이기 때문에
// 중괄호 안에서 선언한 함수 선언문은 호출할 수 없습니다.
welcome(); // Error: welcome is not defined

if문 밖에서 welcome함수를 호출할 방법은 없는걸까..?
함수 표현식을 사용하면 가능하다. if문 밖에 선언한 변수 welcome에 함수 표현식으로 만든 함수를 할당하면 된다. 

***** 함수 선언문과 함수 표현식 중 무엇을 선택해야할까 ?
선언문을 이용해 함수를 선언하는 걸 먼저 고려하는게 좋다. 함수 선언문으로 함수를 정의하면, 함수가 
선언되기 전에 호출할 수 있어서 코드 구성을 좀 더 자유롭게 할 수 있다. 

함수 선언문을 사용하면 가독성도 좋아집니다. 코드에서 let f = function(...) {...} 보다 
function f(...) {...} 을 찾는 게 더 쉽다. 함수 선언 방식이 더 눈길을 사로잡는다. 


요약하자면!
1. 함수는 값이다. 따라서 함수도 값처럼 할당, 복사, 선언할 수 있다.
2. 함수선언문 방식으로 함수를 생성하면, 함수가 독립된 구문 형태로 존재하게 된다. 
3. 함수표현식 방식으로 함수를 생성하면 함수가 표현식의 일부로 존재하게 된다. 
4. 함수선언문은 코드 블록이 실행되기도 전에 처리된다. 따라서 블록 내 어디서든 활용 가능하다.
5. 함수표현식은 실행 흐름이 표현식에 다다랐을 때 만들어진다. 

*/